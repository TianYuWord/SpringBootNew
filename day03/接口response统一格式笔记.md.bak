#Response 统一格式
##一，本课程目标
1，弄清楚为什么要对springboot，所有Controller的response做统一格式封装？
1，学会用ResponseBodyAdvice接口 和 @ControllerAdvice注解

##二，为什么要对springboot的接口返回值统一标准格式？
我们先来看下，springboot默认情况下的response是什么格式的

###第一种格式：response为Spring

```
@ApiOperation("获得字符接口")
@GetMapping("/string")
	public String getString(){
	return "test";
}
```

以上SpringBoot的返回值为

```
test
```

### 第二种格式：response为Object

```
@GetMapping("/user/{id}")
@ApiOperation("通过id获得用户信息")
	public User getOUser(@PathVariable("id") Integer id){
	User user = new User();
	user.setUsername("temp");
	user.setPassword("123456");
	user.setId(id);
	return user;
}
```

以上SpringBoot返回值格式为

```
Response body
{
  "id": 12,
  "username": "temp",
  "password": "123456",
  "sex": null,
  "phone": null
}
```

### 第三种格式：response为void
```
@GetMapping("/empty")
@ApiOperation("empty")
public void empty(){
}
```
以上SpringBoot返回值格式为空

### 第四种格式：response为异常
```
@GetMapping("/error")
@ApiOperation("error")
public void error(){
	int i = 9/0;
}
```

以上SpringBoot返回值格式为异常
```
{
  "timestamp": "2020-03-10T15:17:56.503+0000",
  "status": 500,
  "error": "Internal Server Error",
  "message": "/ by zero",
  "path": "/user/user"
}
```

以上4种情况 ，如果你和客户端（app h5）开发人员联调接口，他们会很懵逼，因为你给他们的接口没有一个统一的格式，客户端开发人员，不知道如何处理返回值。

故，我们应该统一response的标准格式。
一般的response的标准格式包含3部分：
1，status状态值：代表本次请求response的状态结果。
2，response描述：对本次1状态码的描述。
3，data数据：本次返回的数据。
```
{
	"status" : 0
	"desc" : "成功"
	"data" : "test"
}
```

##四，初级程序员对response代码封装
对response的统一封装，是有一定的技术含量的，我们下来看一下，初级程序员的封装，网上有很多教程是这样写的。
### 步骤1：把标准格式转化为代码
```
{
	"status" : 0
	"desc" : "成功"
	"data" : "test"
}
```
把以上代码转化为Result代码
```
@AllArgsConstructor
@NoArgsConstructor
@Data
public class Result <T> {

    /**
     * 1,status 状态值：代表本次请求response的状态结果。
     */
    private Integer status;

    /**
     * 2,response描述：对本次状态码的描述。
     */
    private String desc;

    /**
     * 3,data数据：本次返回的数据。
     */
    private T data;

    /**
     * 成功，创建ResResult：没data数据
     * @return
     */
    public static Result suc(){
       Result result = new Result();
       result.setResultCode(ResultCode.SUCCESS);
        return result;
    }

    /**
     * 成功，创建ResResult：有data数据
     * @param data
     * @return
     */
    public static Result suc(Object data){
        Result result = new Result();
        result.setResultCode(ResultCode.SUCCESS);
        result.setData(data);
        return result;
    }

    /**
     * 失败指定status，desc
     * @param status
     * @param desc
     * @return
     */
    public static Result fail(Integer status,String desc){
        Result result = new Result();
        result.setStatus(status);
        result.setDesc(desc);
        return result;
    }

    /**
     * 失败，指定ResultCode枚举
     * @param resultCode
     * @return
     */
    public static Result fail(ResultCode resultCode){
        Result result = new Result();
        result.setResultCode(resultCode);
        return result;
    }

    /**
     * 把ResultCode枚举转化为ResResult
     * @param code
     */
    private void setResultCode(ResultCode code){
        this.status = code.code();
        this.desc = code.message();
    }
}
```

### 步骤2：把状态码存在枚举类
```
public enum ResultCode {

    /* 成功状态码 */
    SUCCESS(0,"成功"),

    /* 系统500错误 */
    SYSTEM_ERROR(1000,"系统异常，请稍候重试"),

    /* 参数错误：10001-19999 */
    PARAM_IS_INVALID(10001,"参数无效"),

    /*  用户错误：20001-29999 */
    USER_MAS_EXISTED(20001,"用户名已存在"),

    USER_NOT_FIND(20002,"用户名不存在");

    private Integer code;

    private String message;

    ResultCode(Integer code,String message){
        this.code = code;
        this.message = message;
    }

    public Integer code(){
        return this.code;
    }

    public String message(){
        return this.message;
    }
}

```

### 步骤3：加一个体验类
```
@Api(description = "测试初级程序员接口统一")
@RestController
@RequestMapping("/test")
public class TestController {
    @ApiOperation("初级程序员测试接口")
    @GetMapping(value = "/test")
    public Result getResult(){
        System.out.println(Result.suc("test"));
        return Result.suc("test");
    }
}
```
结论：看到这里应该可以看出这个代码有很多弊端
应为今后你每写一个接口，都要手工指定Result.suc() 这行代码，多累呀？
如果你写这种代码推广给整个公司